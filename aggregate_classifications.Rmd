---
title: "Aggregating Data"
output: html_notebook
---

Once we have our data flattened, we need to take some steps to aggregate, so that we can see, for each event, the different choices and select the "final" classification.  We also need to quantify things like the number of "nothing there" classifications once we have aggregated.  This code will help take care of those steps.

Begin by setting up the workspace
```{r}
rm(list = ls())
library(dplyr)
library(magrittr)
library(stringr)
library(tidyr)
library(ggplot2)
```
### Step 1. Pull in some data and examine it. 

```{r}
Classified<-read.csv("Data/north-country-wild-classifications.03.16.20-flattened.csv", stringsAsFactors = F)
```
This is a very large data set (64229 rows).  But let's take a look at a few things.

1. How many unique subject_ids are there?
```{r}
length(unique(Classified$subject_ids)) #or
n_distinct((Classified$subject_ids))
```
2. How many unique classification_ids are there?
```{r}
length(unique(Classified$classification_id))
```
Now save those in a separate DF called "Class_Tally"

```{r}
Class_Tally <- Classified %>% summarise(Subjects = n_distinct(subject_ids), Classifications = n_distinct(classification_id), Total = length(subject_ids)) 
```

Subject_id is basically equivalent to the "event" identification - and there are approximately 5 of each, which would be the 5 separate classifications of the same subject.

Classification_id is the id for each independent classificiation.  There are a few that are repeated, which correspond to those cases where there was more than one species present in an image.

So we likely need to gather by the subject_id column to determine the many (5) different classificaitons per subject so that we can compare them and determine the "final" classification.
```{r}
Classified<- Classified %>% 
     group_by(subject_ids) %>% # count up the number of distinct classification IDs
     mutate(., num_class = n_distinct(classification_id)) %>% #because there will be >1 row per classification_id if >1 spp
     arrange(., subject_ids, classification_id) 

```
End result is the main DF with a new column indicating the number of classifications for each subject.  Also a smaller DF, Class_Tally, that tells us the number of unique subject_ids, classification_ids, and total classifications.

### Step 2. Check for duplicate classifications
Take a look at the number of species identified per subject_id and classification_id.
 
```{r}
check_spp_counts <- Classified %>% 
     group_by(subject_ids, classification_id) %>% 
     mutate(num_species = n_distinct(choice),
            check_num_spp = n())
#num_species is the number of different choices per subject id.  check_num_spp is the number of observations in the group.

```

Check for duplicates. Need to use function Zooniverse people created
```{r}
check_dups <- function(Classified) {
# This function groups by subject and classification ID (which is per user/classification), then checks whether the number of unique species == the number of submissions. 
     # So, if a person selects lion & zebra, num_species and check_num_species will both = 2. 
     # If a person selects lion, 1, standing and lion, 1, sitting, then num_species = 1 and check_num_species = 2.
     # Note that this error will not be possible in future projects.
     # Also note that we can't actually combine answers in a generalized way, 
     # because "how many" is actually categorical and the values differ for all projects.
  bad_counts <- Classified %>% 
      group_by(subject_ids, classification_id) %>% 
      mutate(num_species = n_distinct(choice),
             check_num_spp = n()) %>%
          filter(., num_species != check_num_spp) 
  check <- bad_counts %>% nrow() %>% as.numeric()
     
    if(check > 0) {
      print("You've got duplicates, dammit")
      return(bad_counts)
     } else if(check == 0) {
        print("You've got no duplicates! Well done!")
     }
}

```

```{r}
bad_counts <- check_dups(Classified)
```
If this is working, it appears that there are no duplicates.

So get a "cleaned classifications" data frame.
```{r}
cleaned_classifications <- Classified %>%
  group_by(subject_ids, classification_id) %>% 
          mutate(., num_species = n_distinct(choice)) %>%
          group_by(., subject_ids, classification_id, num_class, num_species, choice) %>% 
#summarise_all(., sum) # adds up counts for duplicates of spp, only works if everything is numeric
  summarise_all(., first) # takes the first record per user per species classification


check_dups(cleaned_classifications)

```


### Step 3. Obtain subject-level metrics

```{r}
subject_metrics <- cleaned_classifications %>% ungroup %>%
     group_by(., subject_ids) %>%
     mutate(., num_votes = n(), # if a  user ids >1 spp, there will be more votes than classifications
            diff_species = n_distinct(choice)) # count the total number of different species reported by different users, for pielous score

glimpse(subject_metrics)
```
Calculate aggregate number of species per subject by taking the median number of species reported across all volunteers, and tie back to subject metrics.
```{r}
species_counts <- cleaned_classifications %>% ungroup %>%
     group_by(subject_ids, classification_id) %>%
     summarise(total_spp_by_user = mean(num_species)) %>% #Need to select only one row per classification_id, then summarise across those. 
     summarise(., agg_num_species = round(median(total_spp_by_user), 0))#aggregate species count, which is median rounded up
     glimpse(species_counts)

cleaned_classifications <- left_join(subject_metrics, species_counts) %>% ungroup
glimpse(cleaned_classifications)
```
### Step 4. Species-level metrics

For each species, aggregate counts.
There's a difference between the proportion of VOTES and the proportion of classifications. 
If some users ID >1 species in a single species image, there will be more votes than classifications. The opposite is true for when some users only ID 1 species in a multi-species image.

We have very few multi-species images, but should take a look.

Group by species. Let's create a DF that provides one row per species ID per classification. We actually don't really need all the grouping variables... could just pull them apart and save for later.
```{r}
grouped_classifications <- cleaned_classifications %>% 
     select(., -num_species) %>% # these aren't relevant
     group_by(., subject_ids, num_class, num_votes, agg_num_species, diff_species, choice) # fields at subject level or higher
```
Tally the votes for each species ID'd within a subject
```{r}
species_votes <- grouped_classifications %>% 
  #for every species within a subject, aggregate votes.
     summarise(., votes = n_distinct(classification_id)) %>% #count up the number of votes per species choice
     mutate(propvote = votes/sum(votes), #calculate proportion of votes for this species
            propclass = votes/num_class) #calculate proportion of classifications for this species
```

Tally votes for factor questions with single YES OR NO answers. Need to idenfity single choice columns. 

Start by renaming the answers.HOWMANY column to get rid of the `answers.` prefix so that we can use it to our advantage for the other columns. Use base r. Then assign a variable to identify this column.
```{r}
names(cleaned_classifications)[names(cleaned_classifications)=="answers.HOWMANY"]<-"How_many"

#do the same for grouped_classifications
names(grouped_classifications)[names(grouped_classifications)=="answers.HOWMANY"]<-"How_many"

howmany_column <- "How_many" # this is a special kind of single-answer column. 
```
Now determine other columns with single_answers.

```{r}
single_answer_columns <- names(select(ungroup(cleaned_classifications), starts_with("answers"))) #the flattening script handily appends this to the front of answer columns. This is why we needed to remove it from the How many column.
```

Need to use 'calc_prop' function defined by Zooniverse people
```{r}
calc_prop <- function(x, NA_action = "non_answer") {
     #NA_action can be non_answer or zero, indicating how NAs should be treated. By default, they are treated as non_answers
     # sum(x)/length(x)  
     
     if (NA_action == "non_answer") {
          prop<- sum(x[!is.na(x)])/length(x[!is.na(x)]) # Remove NAs from both sum and length
          prop <- ifelse(is.finite(prop), prop, NA)          
     } else if (NA_action == "zero") {
          prop<- sum(x, na.rm = T)/length(x) #NAs count towards total length, but not towards the sum of 1s.
     }
     
}
```


```{r}
howmany_votes <- grouped_classifications %>%
     mutate(How_many = dplyr::recode(as.character(How_many), '1' = '1', '2' = '2', '3' = '3')) %>%
     mutate(How_many = as.numeric(How_many)) %>%
     summarise_at(., .vars = howmany_column, list(med_count = median, min_count = min, max_count = max))
```


# Okay, so the full dataset has all of the aggregate votes per species. The only thing left is to select the top n species for each subject.
```{r}
aggregated_data <- full_join(species_votes, grouped_classifications) 

write.csv(aggregated_data, file = "Data/aggregated_data.csv")
```
End result is a new csv that has all of the aggregated data, including the choice and proportion of votes for each species choice.

```{r}
Bad_data <- filter(all_data, diff_species > 1)

     
Final_data <- all_data %>% group_by(subject_ids)
```

```{r}
Good_data <- all_data %>% group_by(subject_ids) %>% summarise(
     votes = length(votes)
)

```



```{r}
Metadata <- read.csv("~/Dropbox/Zooniverse_work/Game Camera Metadata Field Sheets 2019.csv")

Metadata1<- select(Metadata, Date.Out, Date.Checked, SD.Card.Number, Unit.Number) 

names(Metadata1)<- c("Date_Out", "Date_Checked", "SDCard", "Camera")


```

Import final dataset to add dates column. We need to add date in the field and date retrieved in order to calculate species accumulation curve. 
```{r}
Data_Clean_up <- read.csv("~/Dropbox/Statistical_Analysis/Data_Clean_up.csv")

#Be sure the merging columns have the same names and are both characters

Data_Clean_up$Camera<- as.character(Data_Clean_up$Camera)
Data_Clean_up$SDCard<- as.character(Data_Clean_up$SDCard)
Metadata1$Camera<-as.character(Metadata1$Camera)
Metadata1$SDCard<-as.character(Metadata1$SDCard)

joinedData <- left_join(Data_Clean_up, Metadata1, by=c("SDCard", "Camera"), type='right', match='all')

write.csv(joinedData, file = "joinedData.csv")
```

This seemed to match the correct deployment and collection date for each subject_id. Now we can do a species accumulation curve. 

#Species Accumulation Curve
```{r}
joinedData <- read.csv("~/Dropbox/Zooniverse_work/joinedData.csv")
library(vegan)


#Reformulate deployment dates so they are as.dates and they are in the same order for taking the difference later on
joinedData$Date_Checked<- format(as.Date(joinedData$Date_Checked, format="%m/%d/%y"),"%y/%m/%d")

joinedData$Date_Out<- format(as.Date(joinedData$Date_Out, format="%m/%d/%y"),"%y/%m/%d")

#Calculate Camera Trap Days by taking the difference in Date_Out and Date_Checked data. 
joinedData$Camera_Trap_Days<- difftime(joinedData$Date_Checked, joinedData$Date_Out , units = c("days"))

unique(joinedData$Camera_Trap_Days)

#Need to determine how many new species introduced with each additional camera trap day
#Calculate species richness for each camera
Camera_richness <- DF %>% group_by(ForestType, ForestName, Camera) %>% summarise(
  Number_species = n_distinct(choice)
  )

#We only have 20 of our 24 cameras being represented in our dataset
unique(Camera_richness$Camera)

#pull in camera trap days per camera and first image in event
Cam_Trap_Days<- select(joinedData, ForestName, Camera, Camera_Trap_Days, Image1, Date_Out, Date_Checked)

Camera_richness$Camera<- as.character(Camera_richness$Camera)
Camera_richness1 <- left_join(Camera_richness, Cam_Trap_Days, by=c("ForestName", "Camera"), type='right', match='all')

#This gives an output that has 931 observation of 5 variables. This has duplicates that we need to remove to get a dataset that has each camera with associated forest and number of camera trap days. 
#Camera_richness2<- Camera_richness1[!duplicated(Camera_richness1$Camera, Camera_richness1$ForestName),]

#Camera_richness2 has one row for each camera with the forest name, species richness, and camera trap days
#Now calculate species accumulation curve
#library(vegan)
#Camera_richness2<- Camera_richness1[,1:5]=sapply(Camera_richness1[,1:5],as.numeric)
#SpecAccum<- specaccum(Camera_richness2)

#Problem here. Is it possible to calculate species accumulation curve wihen we cannot tell how many new species added each day?
#Trial- add in event (subjectid data) and event date and calculate how many new species each day

R1B1 <- read.csv("~/Dropbox/Zooniverse_work/Round1/R1B1.csv")

ImageDates<- select(R1B1, "FileName", "DateTimeOriginal")

#names(ImageDates)<- c("Image1", "Image_Date")

#ImageDates1<- select(Sifted_data, "Image1")

#ImageDates2<- left_join(ImageDates, ImageDates1, by=c("Image1"), type='right', match='all')

names(ImageDates)<- c("Image1", "DateTimeOriginal")

ImageDates1<- inner_join(ImageDates, Cam_Trap_Days, by=c("Image1"), type='right', match='all')

#ImageDates1 shows the first image per event with associated time of capture. This will hopefully allow us to determine how many new species we got per day. Still need to pull in choice per subject.

#Isolate choices per event to join with the ImageDates1 dataset so we can see which species are selected per event
Choice<- select(Data_Clean_up, "choice", "Image1")

ImageDates2<- inner_join(ImageDates1, Choice, by=c("Image1"), type='right', match='all')

write.csv(ImageDates2, file = "Gus.csv")

#Calculate Species Accumulation Curve
library(vegan)
library(lubridate)
ImageDates2$DateTimeOriginal<- ymd(ImageDates2$DateTimeOriginal)
SpecAccum<- specaccum(ImageDates2, method = "exact", permutations = 100)
plot(SpecAccum)
#This does not work.
```


#Diversity
```{r}
div<-diversity(joinedData, index="shannon")
```


Calculations for richness per camera
```{r}
#This first part did not work for some reason, even though the code should be correct.
#DF$Camera<-as.factor(DF$Camera)

#Spec<- filter(DF, "Camera", "choice")

#Species<- DF %>% group_by(Camera) %>% summarise(
#     n_species = n_distinct(choice)
#)


Cam_3<- filter(DF, Camera == "3")
Cam_4<- filter(DF, Camera == "4")
Cam_8<- filter(DF, Camera == "8")
Cam_9<- filter(DF, Camera == "9")
Cam_11<- filter(DF, Camera == "11")
Cam_14<- filter(DF, Camera == "14")
Cam_15<- filter(DF, Camera == "15")
Cam_17<- filter(DF, Camera == "17")
Cam_18<- filter(DF, Camera == "18")
Cam_21<- filter(DF, Camera == "21")
Cam_22<- filter(DF, Camera == "22")
Cam_24<- filter(DF, Camera == "24")
Cam_25<- filter(DF, Camera == "25")
Cam_28<- filter(DF, Camera == "28")
Cam_29<- filter(DF, Camera == "29")
Cam_31<- filter(DF, Camera == "31")
Cam_32<- filter(DF, Camera == "32")
Cam_33<- filter(DF, Camera == "33")
```











